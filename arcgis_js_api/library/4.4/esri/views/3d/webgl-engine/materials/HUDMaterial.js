// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.4/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/HUDMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUD"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  $commonAttributesAndUniformsHUD\r\n\r\n  uniform float pixelRatio;\r\n  uniform vec2 screenOffset;\r\n  uniform vec2 anchorPos;\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n\r\n  uniform vec4 screenSizePerspective;\r\n\r\n#endif\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n  varying vec3 debugBorderCoords;\r\n#endif\r\n\r\n  attribute vec2 $uv0;\r\n  attribute vec4 $color;\r\n  attribute vec2 $size;\r\n  attribute vec4 $auxpos2;\r\n\r\n  varying vec4 vcolor;\r\n\r\n  varying vec2 vtc;\r\n  varying vec2 vsize;\r\n\r\n  $vvUniforms\r\n\r\n  $alignToPixelCenter\r\n  $alignToPixelOrigin\r\n  $projectPositionHUD\r\n  $vvFunctions\r\n\r\n  void main(void) {\r\n    ProjectHUDAux projectAux;\r\n    vec4 posProj \x3d projectPositionHUD(projectAux);\r\n\r\n    vec2 inputSize;\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n\r\n    inputSize \x3d screenSizePerspectiveScaleVec2($size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\r\n\r\n    vec2 screenOffsetScaled \x3d screenSizePerspectiveScaleFloat(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);\r\n\r\n#else\r\n\r\n    inputSize \x3d $size;\r\n\r\n    vec2 screenOffsetScaled \x3d screenOffset;\r\n#endif\r\n\r\n#ifdef VV_SIZE\r\n    // only use width (.xx) for proportional scaling\r\n    // (if no width was defined in vv, width\r\n    //  will be a copy of height vv)\r\n    inputSize *\x3d vvGetScale($auxpos2).xx;\r\n#endif\r\n\r\n    vec2 combinedSize \x3d inputSize * pixelRatio;\r\n    vec4 quadOffset \x3d vec4(0);\r\n\r\n#ifdef OCCL_TEST\r\n    if (testVisibilityHUD(posProj)) {\r\n#endif\r\n      // UV goes from 0 to 1.99999, where the integer part is used\r\n      // for the normalized vertex coordinates, and the fractional\r\n      // part is used for texture sampling\r\n      vec2 uv01 \x3d floor($uv0);\r\n      vec2 uv \x3d $uv0 - uv01;\r\n\r\n      // Displace icon based on anchor position (normalized for size) and\r\n      // absolute screen offset. anchorPos is [-0.5, 0.5]\r\n      quadOffset.xy \x3d ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;\r\n\r\n#ifdef SIGNED_DISTANCE_FIELD\r\n\r\n      // SDF primitives might be scaled so that the SDF texture resolution does\r\n      // not match the resolution of the canvas, but we still want to render\r\n      // outline-only (\'cross\' and \'x\') primitives cleanly. Aligning to a screen\r\n      // pixel border at the geometry center achieves this, since SDF textures\r\n      // always have power of 2 dimensions.\r\n      posProj \x3d alignToPixelOrigin(posProj, viewport.zw) + quadOffset;\r\n#else\r\n      posProj +\x3d quadOffset;\r\n\r\n      // Aligning vertex positions to the nearest (using \'floor\') screen pixel\r\n      // border renders textures with pixel-perfect results. If the texture\r\n      // resolution does not match the canvas resolution then aligning is\r\n      // redundant.\r\n      if (inputSize.x \x3d\x3d $size.x) {\r\n        posProj \x3d alignToPixelOrigin(posProj, viewport.zw);\r\n      }\r\n#endif\r\n\r\n      gl_Position \x3d posProj;\r\n\r\n      vtc \x3d uv;\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n      debugBorderCoords \x3d vec3(uv01, 1.0 / combinedSize);\r\n#endif\r\n\r\n      vsize \x3d inputSize;\r\n#ifdef OCCL_TEST\r\n    } else {\r\n      vtc \x3d vec2(.0);\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n      debugBorderCoords \x3d vec3(0);\r\n#endif\r\n\r\n    }\r\n#endif\r\n\r\n    gl_Position \x3d posProj;\r\n\r\n#ifdef VV_COLOR\r\n    vcolor \x3d vvGetColor($auxpos2, vvColorValues, vvColorColors);\r\n#else\r\n    vcolor \x3d $color / 255.0;\r\n#endif\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDBaseVariables"\x3e\x3c![CDATA[\r\n  $fsprecisionf\r\n\r\n  #extension GL_OES_standard_derivatives : require\r\n\r\n  uniform sampler2D tex;\r\n  uniform vec4 overrideColor;\r\n  uniform vec4 outlineColor;\r\n  uniform float outlineSize;\r\n\r\n  varying vec4 vcolor;\r\n\r\n  varying vec2 vtc;\r\n  varying vec2 vsize;\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n  varying vec3 debugBorderCoords;\r\n#endif\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDBaseMain"\x3e\x3c![CDATA[\r\n  vec4 premultiply(vec4 v) {\r\n    return vec4(v.rgb * v.a, v.a);\r\n  }\r\n\r\n  void main() {\r\n\r\n#ifdef SIGNED_DISTANCE_FIELD\r\n    vec4 color \x3d vec4(0.0, 0.0, 0.0, 0.0);\r\n    vec4 fillPixelColor \x3d overrideColor * vcolor;\r\n\r\n    // Attempt to sample texel centers to avoid thin cross outline\r\n    // disappearing with large symbol sizes.\r\n    // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041\r\n    const float txSize \x3d 128.0;\r\n    vec2 scaleFactor \x3d ((vsize - txSize) / txSize);\r\n    vec2 samplePos \x3d vtc + vec2(1.0, -1.0) * (1.0 / txSize) * scaleFactor;\r\n\r\n    // Distance in [-0.5, 0.5]\r\n    float d \x3d dot(texture2D(tex, samplePos), vec4(1.0/16777216.0, 1.0/65535.0, 1.0/256.0, 1.0)) - 0.5;\r\n\r\n    // Work around loss of precision for \'d \x3d 0.0\'.\r\n    // \'0\' gets normalised to 0.5 * 256 \x3d 128 before float packing, but can only\r\n    // be stored in the texture as 128 / 255 \x3d 0.502.\r\n    // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603110\r\n    const float diff \x3d (128.0/255.0 - 0.5);\r\n\r\n    // adjust all values, not just those close to 0, to avoid discontinuities in\r\n    // the outlines of other shapes e.g. circles\r\n    d \x3d d - diff;\r\n\r\n    // Distance in output units\r\n    float dist \x3d d * vsize.x;\r\n\r\n    fillPixelColor.a *\x3d clamp(0.5 - dist, 0.0, 1.0);\r\n\r\n    if (outlineSize \x3e 0.25) {\r\n      vec4 outlinePixelColor \x3d outlineColor;\r\n      float clampedOutlineSize \x3d min(outlineSize, 0.5*vsize.x);\r\n      outlinePixelColor.a *\x3d clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\r\n\r\n      // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\r\n      float compositeAlpha \x3d outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n      vec3 compositeColor \x3d vec3(outlinePixelColor) * outlinePixelColor.a +\r\n        vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\r\n      gl_FragColor \x3d vec4(compositeColor, compositeAlpha);\r\n    }\r\n    else {\r\n      gl_FragColor \x3d premultiply(fillPixelColor);\r\n    }\r\n\r\n    // visualize SDF:\r\n    // gl_FragColor \x3d vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\r\n#else\r\n\r\n    // HUDMaterial is rendered with a blending mode that assumes a pre-multiplied\r\n    // fragment color. Input textures should already be pre-multiplied and so\r\n    // don\'t require adjustment, but the override and vertex colors must be\r\n    // modulated by their alpha values.\r\n\r\n    gl_FragColor \x3d texture2D(tex, vtc, -0.5) * premultiply(overrideColor * vcolor);\r\n\r\n#endif\r\n\r\n#ifdef DEBUG_DRAW_BORDER\r\n     float isBorder \x3d float(any(lessThan(debugBorderCoords.xy, vec2(debugBorderCoords.z))) || any(greaterThan(debugBorderCoords.xy, vec2(1.0 - debugBorderCoords.z))));\r\n     gl_FragColor \x3d mix(gl_FragColor, vec4(1, 0, 1, 1), isBorder);\r\n#endif\r\n\r\n    if (gl_FragColor.a \x3c 0.1) {\r\n      discard;\r\n    }\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUD"\x3e\x3c![CDATA[\r\n$fragmentShaderHUDBaseVariables\r\n$fragmentShaderHUDBaseMain\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDHighlight"\x3e\x3c![CDATA[\r\n$fragmentShaderHUDBaseVariables\r\n\r\n  uniform sampler2D depthTex;\r\n  uniform vec4 highlightViewportPixelSz;\r\n\r\n$fragmentShaderHUDBaseMain\r\n    $highlightWrite\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\x3csnippet name\x3d"vertexShaderOcclusionTestPixel"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n  $commonAttributesAndUniformsHUD\r\n\r\n  $alignToPixelCenter\r\n  $projectPositionHUD\r\n\r\n  void main(void) {\r\n    vec4 posProjCenter;\r\n\r\n    // Check for special value of position (0, 0, 0) which is used by the Renderer when graphics\r\n    // are removed before the VBO is recompacted. If this is the case, then we just project outside\r\n    // of clip space.\r\n    if (dot($position, $position) \x3e 0.0) {\r\n      // Render single point to center of the pixel to avoid subpixel filtering to affect\r\n      // the marker color\r\n      ProjectHUDAux projectAux;\r\n      vec4 posProj \x3d projectPositionHUD(projectAux);\r\n\r\n      posProjCenter \x3d alignToPixelCenter(posProj, viewport.zw);\r\n    }\r\n    else {\r\n      // Project out of clip space\r\n      posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\r\n    }\r\n\r\n    gl_Position \x3d posProjCenter;\r\n    gl_PointSize \x3d 1.0;\r\n  }\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n'}});
define("require exports ../../../../core/tsSupport/extendsHelper dojo/text!./HUDMaterial.xml ./internal/MaterialUtil ../lib/Util ../../../webgl/Util ./internal/MaterialBase ./internal/GLMaterialTextureBase ../lib/gl-matrix ../lib/RenderSlot ../lib/ShaderVariations ../lib/ComponentUtils ../../support/aaBoundingRect ../lib/screenSizePerspectiveUtils".split(" "),function(M,ga,y,W,g,m,u,X,E,F,G,I,Y,Z,J){function K(g,b){void 0===b&&(b=N);if(g.textureIsSignedDistanceField){var a=g.anchorPos;g=g.distanceFieldBoundingBox;
var c=b;c[0]=a[0]*(g[2]-g[0])+g[0];c[1]=a[1]*(g[3]-g[1])+g[1]}else O.set(g.anchorPos,b);return b}var O=F.vec2d,r=F.vec3d,P=F.mat3d,z=F.mat4d,Q={"bottom-left":[0,0],bottom:[.5,0],"bottom-right":[1,0],left:[0,.5],center:[.5,.5],right:[1,.5],"top-left":[0,1],top:[.5,1],"top-right":[1,1]},t=[{name:"position",count:3,type:5126,offset:0,stride:76,normalized:!1},{name:"normal",count:3,type:5126,offset:12,stride:76,normalized:!1},{name:"uv0",count:2,type:5126,offset:24,stride:76,normalized:!1},{name:"color",
count:4,type:5121,offset:32,stride:76,normalized:!1},{name:"size",count:2,type:5126,offset:36,stride:76,normalized:!1},{name:"auxpos1",count:4,type:5126,offset:44,stride:76,normalized:!1},{name:"auxpos2",count:4,type:5126,offset:60,stride:76,normalized:!1}],aa={texCoordScale:[1,1],occlusionTest:!0,drawInSecondSlot:!1,color:[1,1,1,1],outlineColor:[1,1,1,1],outlineSize:0,textureIsSignedDistanceField:!1,distanceFieldBoundingBox:null,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],
vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],screenOffset:[0,0],verticalOffset:null,screenSizePerspective:null,screenSizePerspectiveAlignment:null,anchorPos:Q.center,shaderPolygonOffset:1E-5,polygonOffset:!1,textureId:null,centerOffsetUnits:"world",debugDrawBorder:!1};M=function(B){function b(a,c){c=B.call(this,c)||this;c._textureDirty=!1;c.params=g.copyParameters(a,aa);"string"===
typeof c.params.anchorPos&&(c.params.anchorPos=Q[c.params.anchorPos]);return c}y(b,B);b.prototype.dispose=function(){};b.prototype.getParameterValues=function(){var a=this.params;return{color:a.color,texCoordScale:a.texCoordScale,polygonOffset:a.polygonOffset,anchorPos:a.anchorPos,screenOffset:a.screenOffset,verticalOffset:a.verticalOffset,screenSizePerspective:a.screenSizePerspective,screenSizePerspectiveAlignment:a.screenSizePerspectiveAlignment,shaderPolygonOffset:a.shaderPolygonOffset,textureIsSignedDistanceField:a.textureIsSignedDistanceField,
outlineColor:a.outlineColor,outlineSize:a.outlineSize,distanceFieldBoundingBox:a.distanceFieldBoundingBox,vvSizeEnabled:a.vvSizeEnabled,vvSizeMinSize:a.vvSizeMinSize,vvSizeMaxSize:a.vvSizeMaxSize,vvSizeOffset:a.vvSizeOffset,vvSizeFactor:a.vvSizeFactor,vvColorEnabled:a.vvColorEnabled,vvColorValues:a.vvColorValues,vvColorColors:a.vvColorColors,textureId:a.textureId,occlusionTest:a.occlusionTest,centerOffsetUnits:a.centerOffsetUnits,debugDrawBorder:a.debugDrawBorder,drawInSecondSlot:a.drawInSecondSlot}};
b.prototype.setParameterValues=function(a){for(var c in a)"textureId"===c&&m.assert(!!this.params.textureId,"Can only change texture of material that already has a texture"),this.params[c]=a[c];this.notifyDirty("matChanged")};b.prototype.getParams=function(){return this.params};b.prototype.getOutputAmount=function(a){return 114*a};b.prototype.getInstanceBufferLayout=function(){};b.prototype.getVertexBufferLayout=function(){return t};b.prototype.fillInterleaved=function(a,c,d,f,e,b){var n=4*b,l=a.faces.indices[m.VertexAttrConstants.POSITION],
q=a.vertexAttr[m.VertexAttrConstants.POSITION].data,h=b+u.findAttribute(t,m.VertexAttrConstants.POSITION).offset/4;for(f=0;f<l.length;++f){var k=3*l[f];g.fill(q,k,e,h,c,3);h+=19;g.fill(q,k,e,h,c,3);h+=19;g.fill(q,k,e,h,c,3);h+=19;g.fill(q,k,e,h,c,3);h+=19;g.fill(q,k,e,h,c,3);h+=19;g.fill(q,k,e,h,c,3);h+=19}c=a.faces.indices[m.VertexAttrConstants.NORMAL];q=a.vertexAttr[m.VertexAttrConstants.NORMAL].data;h=b+u.findAttribute(t,m.VertexAttrConstants.NORMAL).offset/4;for(f=0;f<c.length;++f)k=3*c[f],g.fill(q,
k,e,h,d,3),h+=19,g.fill(q,k,e,h,d,3),h+=19,g.fill(q,k,e,h,d,3),h+=19,g.fill(q,k,e,h,d,3),h+=19,g.fill(q,k,e,h,d,3),h+=19,g.fill(q,k,e,h,d,3),h+=19;f=a.vertexAttr[m.VertexAttrConstants.UV0].data;null==f||3>=f.length?(d=k=0,c=this.params.texCoordScale[0],q=this.params.texCoordScale[1]):(k=a.vertexAttr[m.VertexAttrConstants.UV0].data[0],d=a.vertexAttr[m.VertexAttrConstants.UV0].data[1],c=a.vertexAttr[m.VertexAttrConstants.UV0].data[2],q=a.vertexAttr[m.VertexAttrConstants.UV0].data[3]);c=Math.min(1.99999,
c+1);q=Math.min(1.99999,q+1);h=b+u.findAttribute(t,m.VertexAttrConstants.UV0).offset/4;for(f=0;f<l.length;++f)e[h]=k,e[h+1]=d,h+=19,e[h]=c,e[h+1]=d,h+=19,e[h]=c,e[h+1]=q,h+=19,e[h]=c,e[h+1]=q,h+=19,e[h]=k,e[h+1]=q,h+=19,e[h]=k,e[h+1]=d,h+=19;l=a.faces.indices[m.VertexAttrConstants.COLOR];d=a.vertexAttr[m.VertexAttrConstants.COLOR].data;n+=u.findAttribute(t,m.VertexAttrConstants.COLOR).offset;c=new Uint8Array(e.buffer);for(f=0;f<l.length;++f)k=4*l[f],g.fill(d,k,c,n,null,4),n+=76,g.fill(d,k,c,n,null,
4),n+=76,g.fill(d,k,c,n,null,4),n+=76,g.fill(d,k,c,n,null,4),n+=76,g.fill(d,k,c,n,null,4),n+=76,g.fill(d,k,c,n,null,4),n+=76;k=a.faces.indices[m.VertexAttrConstants.SIZE];n=a.vertexAttr[m.VertexAttrConstants.SIZE].data;l=b+u.findAttribute(t,m.VertexAttrConstants.SIZE).offset/4;for(f=0;f<k.length;++f)d=n[2*k[f]],c=n[2*k[f]+1],e[l]=d,e[l+1]=c,l+=19,e[l]=d,e[l+1]=c,l+=19,e[l]=d,e[l+1]=c,l+=19,e[l]=d,e[l+1]=c,l+=19,e[l]=d,e[l+1]=c,l+=19,e[l]=d,e[l+1]=c,l+=19;if(null!=a.faces.indices[m.VertexAttrConstants.AUXPOS1]&&
null!=a.vertexAttr[m.VertexAttrConstants.AUXPOS1])for(n=a.faces.indices[m.VertexAttrConstants.AUXPOS1],l=a.vertexAttr[m.VertexAttrConstants.AUXPOS1].data,d=b+u.findAttribute(t,"auxpos1").offset/4,f=0;f<n.length;++f)k=4*n[f],g.fill(l,k,e,d,null,4),d+=19,g.fill(l,k,e,d,null,4),d+=19,g.fill(l,k,e,d,null,4),d+=19,g.fill(l,k,e,d,null,4),d+=19,g.fill(l,k,e,d,null,4),d+=19,g.fill(l,k,e,d,null,4),d+=19;if(null!=a.faces.indices[m.VertexAttrConstants.AUXPOS2]&&null!=a.vertexAttr[m.VertexAttrConstants.AUXPOS2])for(n=
a.faces.indices[m.VertexAttrConstants.AUXPOS2],a=a.vertexAttr[m.VertexAttrConstants.AUXPOS2].data,b+=u.findAttribute(t,"auxpos2").offset/4,f=0;f<n.length;++f)k=4*n[f],g.fill(a,k,e,b,null,4),b+=19,g.fill(a,k,e,b,null,4),b+=19,g.fill(a,k,e,b,null,4),b+=19,g.fill(a,k,e,b,null,4),b+=19,g.fill(a,k,e,b,null,4),b+=19,g.fill(a,k,e,b,null,4),b+=19};b.prototype.intersect=function(a,c,d,f,e,b,g,l){if(f.isSelection&&f.enableHUDSelection&&!Y.isAllHidden(c.componentVisibilities,a.data.componentOffsets)){c=this.params;
b=e=1;l&&(b=l(R),e=b[0],b=b[5]);l=a.getData().getVertexAttr()[m.VertexAttrConstants.POSITION];var n=a.getData().getVertexAttr()[m.VertexAttrConstants.SIZE];a=a.getData().getVertexAttr()[m.VertexAttrConstants.NORMAL];m.assert(3<=l.size);for(var h=f.point,k=f.camera,B=K(c),D=0;D<l.data.length/l.size;D++){var p=D*l.size;r.set3(l.data[p],l.data[p+1],l.data[p+2],A);z.multiplyVec3(d,A,A);p=D*n.size;v[0]=n.data[p]*e;v[1]=n.data[p+1]*b;z.multiplyVec3(k.viewMatrix,A);p=D*a.size;r.set3(a.data[p],a.data[p+1],
a.data[p+2],S);this.applyVerticalOffsetTransformation(A,S,d,k,T);k.applyProjection(A,C);if(-1<C[0]){var p=Math.floor(C[0]),w=Math.floor(C[1]);J.applyPrecomputedScaleFactorVec2(v,T.factor,v);var p=p-H-(0<B[0]?v[0]*B[0]:0),x=p+v[0]+2*H,w=w-H-(0<B[1]?v[1]*B[1]:0),t=w+v[1]+2*H;if(c.textureIsSignedDistanceField)var u=c.outlineSize/2,y=c.distanceFieldBoundingBox,p=p+v[0]*y[0],w=w+v[1]*y[1],x=x-v[0]*(1-y[2]),t=t-v[1]*(1-y[3]),p=p-u,x=x+u,w=w-u,t=t+u;h[0]>p&&h[0]<x&&h[1]>w&&h[1]<t&&(x=f.p0,w=f.p1,z.multiplyVec3(z.inverse(k.viewMatrix,
ba),A,U),C[0]=h[0],C[1]=h[1],k.unprojectPoint(C,A),p=r.negate(f.getDirection(),r.create()),x=r.dist(x,A)/r.dist(x,w),g(x,p,-1,1,!0,U))}}}};b.prototype.normalAndViewAngle=function(a,c,d,f){void 0===f&&(f=L);P.multiplyVec3(z.toMat3(c,ca),a,f.normal);z.multiplyVec3(d.viewInverseTransposeMatrix,f.normal);f.cosAngle=r.dot(V,da);return f};b.prototype.updateScaleInfo=function(a,c,d){c=this.params;c.screenSizePerspective?a.factor=J.precomputeScaleFactor(L.cosAngle,d,c.screenSizePerspective,a.factor):(a.factor.scale=
1,a.factor.factor=0,a.factor.minPixelSize=0,a.factor.paddingPixels=0);c.screenSizePerspectiveAlignment?(a.scaleAlignment=J.precomputeScale(L.cosAngle,d,c.screenSizePerspectiveAlignment),a.minPixelSizeAlignment=c.screenSizePerspectiveAlignment.parameters.minPixelSize):(a.scaleAlignment=a.factor.scale,a.minPixelSizeAlignment=a.factor.minPixelSize)};b.prototype.applyVerticalOffsetTransformation=function(a,c,d,f,b,m){var e=this.params;if(!e.verticalOffset||!e.verticalOffset.screenLength)return b&&(e.screenSizePerspective||
e.screenSizePerspectiveAlignment)?(f=this.normalAndViewAngle(c,d,f),e=r.length(a),this.updateScaleInfo(b,f.cosAngle,e)):b&&(b.factor.scale=1,b.scaleAlignment=1),m?r.set(a,m):a;c=this.normalAndViewAngle(c,d,f);d=r.length(a);f=g.verticalOffsetAtDistance(f,d,e.verticalOffset,c.cosAngle,e.screenSizePerspectiveAlignment||e.screenSizePerspective);b&&this.updateScaleInfo(b,c.cosAngle,d);return r.add(a,r.scale(c.normal,f),m)};b.prototype.getGLMaterials=function(){return{color:ea,depthShadowMap:void 0,normal:void 0,
depth:void 0,highlight:fa}};b.prototype.getAllTextureIds=function(){return[this.params.textureId]};b.prototype.setTextureDirty=function(){this._textureDirty=!0};b.prototype.calculateRelativeScreenBounds=function(a,c,d){void 0===d&&(d=Z.create());var b=this.params,e=d;void 0===e&&(e=N);O.set(b.anchorPos,e);e[0]*=-a[0];e[1]*=-a[1];e[0]+=b.screenOffset[0]*c;e[1]+=b.screenOffset[1]*c;d[2]=d[0]+a[0];d[3]=d[1]+a[1];return d};b.prototype.calculateAnchorPosForRendering=function(a){return K(this.params,a)};
b.loadShaders=function(a,c,d,b){a._parse(W);var e=function(a){a.addDefine("OcclTest","OCCL_TEST");a.addDefine("SDF","SIGNED_DISTANCE_FIELD");a.addDefine("vvSize","VV_SIZE");a.addDefine("vvColor","VV_COLOR");a.addDefine("verticalOffset","VERTICAL_OFFSET");a.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");a.addDefine("centerOffsetUnitsScreen","CENTER_OFFSET_UNITS_SCREEN")},f=new I("hud",["vertexShaderHUD","fragmentShaderHUD"],null,d,c,a,b);e(f);f.addDefine("debugDrawBorder","DEBUG_DRAW_BORDER");
d.addShaderVariations("hud-material-shader-variations",f);f=new I("hudHighlight",["vertexShaderHUD","fragmentShaderHUDHighlight"],null,d,c,a,b);e(f);d.addShaderVariations("hud-material-highlight-shader-variations",f);a=new I("hudOcclusionTestPixel",["vertexShaderOcclusionTestPixel","fragmentShaderSimple"],null,d,c,a,b);a.addDefine("verticalOffset","VERTICAL_OFFSET");a.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");a.addDefine("centerOffsetUnitsScreen","CENTER_OFFSET_UNITS_SCREEN");d.addShaderVariations("hud-material-occlusion-test-pixel-shader-variations",
a)};return b}(X.MaterialBase);E=function(m){function b(a,c,d){d=m.call(this,a,a.getParams(),c,d)||this;d.programRep=c;d.params=g.copyParameters(a.getParams());d.selectProgram();d.selectSlot();return d}y(b,m);b.prototype.selectSlot=function(){this.mainSlot=this.params.drawInSecondSlot?G.HUDMATERIAL2:G.HUDMATERIAL1};b.prototype.beginSlot=function(a){return a===this.mainSlot};b.prototype.getProgram=function(){return this.program};b.prototype.getAllPrograms=function(){return[this.program]};b.prototype.updateParameters=
function(){var a=this.material.getParams(),c=this.params;c.color=a.color;c.texCoordScale=a.texCoordScale;c.polygonOffset=a.polygonOffset;c.anchorPos=a.anchorPos;c.screenOffset=a.screenOffset;c.verticalOffset=a.verticalOffset;c.screenSizePerspective=a.screenSizePerspective;c.screenSizePerspectiveAlignment=a.screenSizePerspectiveAlignment;c.shaderPolygonOffset=a.shaderPolygonOffset;c.textureIsSignedDistanceField=a.textureIsSignedDistanceField;c.outlineColor=a.outlineColor;c.outlineSize=a.outlineSize;
c.vvSizeEnabled=a.vvSizeEnabled;c.vvSizeMinSize=a.vvSizeMinSize;c.vvSizeMaxSize=a.vvSizeMaxSize;c.vvSizeOffset=a.vvSizeOffset;c.vvSizeFactor=a.vvSizeFactor;c.vvColorEnabled=a.vvColorEnabled;c.vvColorValues=a.vvColorValues;c.vvColorColors=a.vvColorColors;this.updateTexture(a.textureId);this.selectProgram();this.selectSlot()};b.prototype.bindRender=function(a,c){var d=this.params,b=this.getProgram();this.bindTexture(a,b);b.setUniform1i("hudVisibilityTexture",1);a.bindTexture(c.hudVisibilityTexture,
1);a.setActiveTexture(0);b.setUniform4fv("overrideColor",d.color);b.setUniform1f("pixelRatio",c.pixelRatio);d.textureIsSignedDistanceField&&(b.setUniform4fv("outlineColor",d.outlineColor),b.setUniform1f("outlineSize",d.outlineSize));d.vvSizeEnabled&&(b.setUniform3fv("vvSizeMinSize",d.vvSizeMinSize),b.setUniform3fv("vvSizeMaxSize",d.vvSizeMaxSize),b.setUniform3fv("vvSizeOffset",d.vvSizeOffset),b.setUniform3fv("vvSizeFactor",d.vvSizeFactor));d.vvColorEnabled&&(b.setUniform1fv("vvColorValues",d.vvColorValues),
b.setUniform4fv("vvColorColors",d.vvColorColors));b.setUniform2fv("texScale",d.texCoordScale);b.setUniform2f("screenOffset",2*d.screenOffset[0],2*d.screenOffset[1]);b.setUniform2fv("anchorPos",K(d));d.polygonOffset&&(a.setPolygonOffsetFillEnabled(!0),a.setPolygonOffset(0,-4));a.setBlendingEnabled(!0);a.setBlendFunction(1,771)};b.prototype.bindProjection=function(a,c){this.material._textureDirty&&(this.renderTexture(a),this.material._textureDirty=!1);var b=c.cameraAboveGround?1:-1,f=this.getProgram(),
e=this.params;a.bindProgram(f);f.setUniform1f("cameraGroundRelative",b);f.setUniform1f("polygonOffset",e.shaderPolygonOffset);f.setUniform4fv("viewport",c.viewport);g.bindVerticalOffset(e.verticalOffset,c,f);f.setUniformMatrix4fv("viewNormal",c.viewInvTransp);e.screenSizePerspective&&(g.bindScreenSizePerspective(e.screenSizePerspective,f,"screenSizePerspective"),g.bindScreenSizePerspective(e.screenSizePerspectiveAlignment||e.screenSizePerspective,f,"screenSizePerspectiveAlignment"))};b.prototype.releaseRender=
function(a){a.setPolygonOffsetFillEnabled(!1);a.setBlendFunction(770,771);a.setBlendingEnabled(!1)};b.prototype.bindView=function(a,c){a=c.origin;var b=this.getProgram();g.bindView(a,c.view,b);g.bindCamPos(a,c.viewInvTransp,b)};b.prototype.bindInstance=function(a,c){a=this.getProgram();a.setUniformMatrix4fv("model",c.transformation);a.setUniformMatrix4fv("modelNormal",c.transformationNormal)};b.prototype.getDrawMode=function(a){return a.gl.TRIANGLES};return b}(E.GLMaterialTextureBase);var ea=function(g){function b(a,
c,b){a=g.call(this,a,c,b)||this;a.isOcclusionSlot=!1;return a}y(b,g);b.prototype.selectProgram=function(){var a=this.params;this.programOcclusionTestPixel=this.programRep.getShaderVariationsProgram("hud-material-occlusion-test-pixel-shader-variations",[!!a.verticalOffset,!!a.screenSizePerspective,"screen"===a.centerOffsetUnits]);this.program=this.programRep.getShaderVariationsProgram("hud-material-shader-variations",[a.occlusionTest,a.textureIsSignedDistanceField,!!a.vvSizeEnabled,!!a.vvColorEnabled,
!!a.verticalOffset,!!a.screenSizePerspective,"screen"===a.centerOffsetUnits,!!a.debugDrawBorder])};b.prototype.getDrawMode=function(a){a=a.gl;return this.isOcclusionSlot?a.POINTS:a.TRIANGLES};b.prototype.release=function(a){a.setDepthFunction(a.gl.LESS);this.isOcclusionSlot||this.releaseRender(a)};b.prototype.bind=function(a,c){var b=a.gl;this.bindProjection(a,c);var f=this.getProgram();a.setDepthFunction(b.LEQUAL);this.isOcclusionSlot?f.setUniform4f("color",1,1,1,1):(this.bindRender(a,c),this.bindTexture(a,
f))};b.prototype.getProgram=function(){return this.isOcclusionSlot?this.programOcclusionTestPixel:this.program};b.prototype.getAllPrograms=function(){return[this.programOcclusionTestPixel,this.program]};b.prototype.beginSlot=function(a){if(this.params.occlusionTest)return this.isOcclusionSlot=a===G.OCCLUSION_PIXELS,a===G.OCCLUSION_PIXELS||a===this.mainSlot;this.isOcclusionSlot=!1;return a===this.mainSlot};return b}(E),fa=function(g){function b(){return null!==g&&g.apply(this,arguments)||this}y(b,
g);b.prototype.selectProgram=function(){var a=this.params;this.program=this.programRep.getShaderVariationsProgram("hud-material-highlight-shader-variations",[a.occlusionTest,a.textureIsSignedDistanceField,!!a.vvSizeEnabled,!!a.vvColorEnabled,!!a.verticalOffset,!!a.screenSizePerspective,"screen"===a.centerOffsetUnits])};b.prototype.bind=function(a,b){this.bindProjection(a,b);this.bindRender(a,b)};b.prototype.release=function(a){this.releaseRender(a)};return b}(E),T={factor:{scale:0,factor:0,minPixelSize:0,
paddingPixels:0},scaleAlignment:0,minPixelSizeAlignment:0},N=[0,0],A=r.create(),S=r.create(),C=r.create(),V=r.create(),U=r.create(),ca=P.create(),ba=z.create(),L={normal:V,cosAngle:0},R=z.create();z.identity(R);var H=1,v=[0,0],da=[0,0,1];return M});